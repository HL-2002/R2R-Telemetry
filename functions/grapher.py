import matplotlib.pyplot as plt
import matplotlib.animation as animation
from generator import generate

"""
Grapher module to plot the data generated by the generator function in real-time.

The data will be plotted in a column of many subplots, each one representing a channel of data
from the data dictionary of the shape:
- {channel_name: value, ...}

The plots will have either a time or distance (speed * distance) as the x-axis, and the value of the
channel as the y-axis.

Plotting will occur only if there's data to plot, otherwise it'll wait for data to be inputted.
"""

# TODO: Needs optimization, as it starts to lag incresingly after a couple of seconds of 
# running (Approx. after 200 hundred points have been plotted).
# For benchmark, the plot should be able to run for at least 5`` minutes without lagging.
def time_plot(channels: dict, hz: int):
    """
    Real time plot of the data generated by the generator function, with time as the x-axis.
    """
    # Style
    plt.style.use("ggplot")

    # Creates the fig and line2D artist to initialize plot and animate it later
    # data ini
    interval = (1 / hz) * 1000

    # set axes
    # TODO: adapt lists to np.arrays
    xs = []
    ys = {channel: [] for channel in channels}

    # Fig ini
    fig, ax = plt.subplots(len(channels))

    # Style modification
    # TODO: Need to adapt for when there's only one channel
    # TODO: Need to style it properly, including x labels second to second
    for i, channel in enumerate(channels):
        ax[i].title.set_text(channel)

    # Real-time plot
    anim = animation.FuncAnimation(
        fig=fig,
        func=update,
        fargs=(xs, ys, ax, channels, hz),
        interval=interval,
        repeat=False,
    )

    # Show plot
    plt.show()


def dist_plot(channel: dict, hz: float): 
    """
    Real time plot of the data generated by the generator function, with distance as the x-axis.
    """
    ...


def plot(data:dict, x:str):
    """
    Plot of the stored data, with time or distance as the x-axis.
    """
    ...


# Helper functions
def update(frame: int, xs: list, ys: dict, ax: plt.axes, channels: dict, hz: int):
    # Get data
    # TODO: X should be actual time running, not an estimate of 1/hz times the iteration
    x = 1 / hz
    y = generate(channels, hz)

    # Append data
    if len(xs) == 0:
        xs.append(x)
    else:
        xs.append(x * (len(xs) + 1))

    for channel in ys:
        ys[channel].append(y[channel])

    # Limit data for performance
    ys = {channel: ys[channel][-100:] for channel in ys}
    xs = xs[-100:]

    # Plot data
    # TODO: Need to adapt for when there's only one channel
    for i, channel in enumerate(channels):
        ax[i].clear()
        ax[i].plot(xs, ys[channel], "r")


if __name__ == "__main__":
    channels = {
        "speed": {
            "min": 0,
            "max": 300,
        },
        "rpms": {
            "min": 0,
            "max": 8000,
        },
        "temperature": {
            "min": 0,
            "max": 100,
        },
    }

    time_plot(channels, 100)
